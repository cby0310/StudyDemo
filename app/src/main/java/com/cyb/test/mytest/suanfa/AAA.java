package com.cyb.test.mytest.suanfa;

/**
 * https://krahets.gitee.io/views/sword-for-offer/2020-05-20-sword-for-offer-00.html
 * 二分查找、归并、快排
 * 1:x ->
 * 2:x ->
 * 3:数组中重复的数字 -> 51
 * 4:二维数组中的查找 -> 100
 * 5:替换空格 -> 4
 * 6:从尾到头打印链表 -> 5
 * 7:重建二叉树 -> 6
 * 8:二叉树的下一个节点 -> 58
 * 9:两个栈实现一个队列 -> 7
 * 10:斐波那契数列第N项、青蛙跳台阶、大矩形放小矩形 -> 9
 * 11:旋转数组中的最小数字:二分查找 -> 8 力扣牛逼
 * 12:矩阵中的路径：回溯法 -> 66
 * 13:机器人的运动范围：回溯 -> 67
 * 14:剪绳子：动态规划、贪婪算法 -> 102  https://www.cnblogs.com/aiguozou/p/11576036.html
 * 15:二进制中1的个数 -> 10
 * 16:数值的整数次方:考虑指数为负数的情况，使用递归&位运算优化迭代相乘的过程 -> 114
 * 17:打印从1到最大的n位数：考虑大数的问题，其实考察的全排列 -> 115
 * 18:删除链表中的节点 -> 57
 * 19:正则表达式匹配 -> 63 ???
 * 20:表示数值的字符串 -> 54
 * 21:调整数组顺序使奇数位于偶数前面 -> 14
 * 22:链表中倒数第k个节点 -> 15
 * 23:链表中环的入口节点 -> 56
 * 24:反转链表 -> 103
 * 25:合并两个排序的链表 -> 17  104
 * 26:树的子结构 -> 105
 * 27:对称的二叉树 -> 19  106
 * 28:对称的二叉树 -> 59  tree1 左子树与 tree2 右子树相等，tree1 右子树与 tree2 左子树相等
 * 29:顺时针打印矩阵 -> 20
 * 30:包含min函数的栈 -> 21 解法有点问题，正确是使用一个辅助栈来保存每步的最小值 或者为节点添加一个min属性
 * 31:栈的压入、弹出序列 -> 22 很巧妙
 * 32:从上到下打印二叉树 -> 60 广度优先遍历，使用队列实现
 * 33:二叉搜索树的后序遍历序列 -> 24
 * 34:二叉树中和为某一值的路径 -> 25 要记住
 * 35:复杂链表的复制 -> 26 ???
 * 36:二叉搜索树与双向链表 -> 27  只能说思路牛逼
 * 37:序列化二叉树 -> 62 107
 * 38:字符串的排列 -> 28  108  扩展还得看下
 * 39:数组中出现次数超过一半的数字 -> 29
 * 40:最小的k个数 -> 30
 * 41:数据流中的中位数 -> 64
 * 42:连续子数组的最大和 -> 31
 * 43:1~n整数中1出现的次数 -> 32看不懂 https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/
 * 44:数字序列中某一位的数字 -> ？？ fuck
 * 45:把数组排成最小的数 ->
 * 46:把数字翻译成字符串 -> 109
 * 47:礼物的最大价值 -> 110
 * 48:最长不含重复字符的子字符串 -> 111 哈希表
 * 49:丑数 -> 34
 * 50:第一个只出现一次的字符 ->  35 哈希表
 * 51:数组中的逆序对 -> 36 归并排序
 * 52:两个链表的第一个公共节点 -> 37  正难则反
 * 53:在排序数组中查找数字 -> 112  38
 * 54:二叉搜索树的第k大节点 中序遍历倒序，记得是倒序
 * 55:二叉树的深度 -> 39
 * 56:数组中数字出现的次数 -> 40
 * 57:和为s的数字 -> 41
 * 58:翻转字符串 -> 42
 * 59:队列的最大值 -> 113
 * 60:n个骰子🎲的点数 ->  43  ？?
 * 61:扑克牌中的顺子 -> 44
 * 62:圆圈中最后剩下的数字 ->
 * 63:股票的最大利润 -> 101
 * 64:求1+2+...+n -> 46
 * 65:不用加减乘除做加法 -> 47
 * 66:构建乘积数组 -> 52
 */
public class AAA {
}
