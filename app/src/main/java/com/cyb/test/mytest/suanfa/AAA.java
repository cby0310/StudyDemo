package com.cyb.test.mytest.suanfa;

/**
 * 二分查找、归并、快排
 * 1:x ->
 * 2:x ->
 * 3:数组中重复的数字 -> 51
 * 4:二维数组中的查找 -> 100
 * 5:替换空格 -> 4
 * 6:从尾到头打印链表 -> 5
 * 7:重建二叉树 -> 6
 * 8:二叉树的下一个节点 -> 58
 * 9:两个栈实现一个队列 -> 7
 * 10:斐波那契数列第N项、青蛙跳台阶、大矩形放小矩形 -> 9
 * 11:旋转数组中的最小数字:二分查找 -> 8 ~
 * 12:矩阵中的路径：回溯法 -> 66
 * 13:机器人的运动范围：回溯 -> 67
 * 14:剪绳子：动态规划、贪婪算法 -> 102 ???  https://www.cnblogs.com/aiguozou/p/11576036.html
 * 15:二进制中1的个数 -> 10
 * 16:数值的整数次方:考虑指数为负数的情况，使用递归&位运算优化迭代相乘的过程 ->
 * 17:打印从1到最大的n位数：考虑大数的问题，用数组实现 ->
 * 18:删除链表中的节点 -> 57
 * 19:正则表达式匹配 -> 63 ???
 * 20:表示数值的字符串 -> 54
 * 21:调整数组顺序使奇数位于偶数前面 -> 14
 * 22:链表中倒数第k个节点 -> 15
 * 23:链表中环的入口节点 -> 56
 * 24:反转链表 -> 103
 * 25:合并两个排序的链表 -> 17  104
 * 26:树的子结构 -> 105
 * 27:对称的二叉树 -> 19  106
 * 28:对称的二叉树 -> 59  tree1 左子树与 tree2 右子树相等，tree1 右子树与 tree2 左子树相等
 * 29:顺时针打印矩阵 -> 20
 * 30:包含min函数的栈 -> 21 解法有点问题，正确是使用一个辅助栈来保存每步的最小值 或者为节点添加一个min属性
 * 31:栈的压入、弹出序列 -> 22 很巧妙
 * 32:从上到下打印二叉树 -> 60 广度优先遍历，使用队列实现
 * 33:二叉搜索树的后序遍历序列 -> 24
 * 34:二叉树中和为某一值的路径 -> 25 要记住
 * 35:复杂链表的复制 -> 26 ???
 * 36:二叉搜索树与双向链表 -> 27  只能说思路牛逼
 * 37:序列化二叉树 -> 62 107
 * 38:字符串的排列 -> 28  108  扩展还得看下
 * 39:数组中出现次数超过一半的数字 -> 29
 * 40:最小的k个数 -> 30
 * 41:数据流中的中位数 -> 64
 * 42:连续子数组的最大和 -> 31
 * 43:1~n整数中1出现的次数 ->
 * ->
 * ->
 * ->
 * ->
 * ->
 */
public class AAA {
}
